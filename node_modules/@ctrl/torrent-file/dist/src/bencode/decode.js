import { stringToUint8Array, uint8ArrayToString } from 'uint8array-extras';
import { isValidUTF8 } from './utils.js';
const td = new TextDecoder();
class Decoder {
    buf;
    idx = 0;
    constructor(buf) {
        this.buf = buf;
    }
    readByte() {
        if (this.idx >= this.buf.length) {
            return null;
        }
        return String.fromCharCode(this.buf[this.idx++]);
    }
    readBytes(length) {
        if (this.idx + length > this.buf.length) {
            throw new Error(`could not read ${length} bytes, insufficient content`);
        }
        const result = this.buf.slice(this.idx, this.idx + length);
        this.idx += length;
        return result;
    }
    readUntil(char) {
        const targetIdx = this.buf.indexOf(char.charCodeAt(0), this.idx);
        if (targetIdx === -1) {
            throw new Error(`could not find terminated char: ${char}`);
        }
        const result = this.buf.slice(this.idx, targetIdx);
        this.idx = targetIdx;
        return result;
    }
    readNumber() {
        const buf = this.readUntil(':');
        return parseInt(uint8ArrayToString(buf), 10);
    }
    peekByte() {
        if (this.idx >= this.buf.length) {
            return '';
        }
        const result = this.readByte();
        if (result === null) {
            return '';
        }
        this.idx--;
        return result;
    }
    assertByte(expected) {
        const b = this.readByte();
        if (b !== expected) {
            throw new Error(`expecte ${expected}, got ${b}`);
        }
    }
    next() {
        switch (this.peekByte()) {
            case 'd': {
                return this.nextDictionary();
            }
            case 'l': {
                return this.nextList();
            }
            case 'i': {
                return this.nextNumber();
            }
            default: {
                return this.nextBufOrString();
            }
        }
    }
    nextBufOrString() {
        const length = this.readNumber();
        this.assertByte(':');
        const buf = this.readBytes(length);
        return isValidUTF8(buf) ? td.decode(buf) : buf;
    }
    nextString() {
        const length = this.readNumber();
        this.assertByte(':');
        return td.decode(this.readBytes(length));
    }
    nextNumber() {
        this.assertByte('i');
        const content = td.decode(this.readUntil('e'));
        this.assertByte('e');
        const result = Number(content);
        if (isNaN(result)) {
            throw new Error(`not a number: ${content}`);
        }
        return result;
    }
    nextList() {
        this.assertByte('l');
        const result = [];
        while (this.peekByte() !== 'e') {
            result.push(this.next());
        }
        this.assertByte('e');
        return result;
    }
    nextDictionary() {
        this.assertByte('d');
        const result = {};
        while (this.peekByte() !== 'e') {
            result[this.nextString()] = this.next();
        }
        this.assertByte('e');
        return result;
    }
}
export const decode = (payload) => {
    let buf;
    if (typeof payload === 'string') {
        buf = stringToUint8Array(payload);
    }
    else if (payload instanceof ArrayBuffer) {
        buf = new Uint8Array(payload);
    }
    else if ('buffer' in payload) {
        buf = new Uint8Array(payload.buffer);
    }
    else {
        throw new Error(`invalid payload type`);
    }
    const decoder = new Decoder(buf);
    return decoder.next();
};
